<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Geo-Triggered AR Cube</title>
    <meta name="description" content="Geo-triggered AR cube example">
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.2/aframe/build/aframe-ar.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      /* üß≠ Force button to stay on top of AR view */
      #setLocationBtn {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 20px;
        font-size: 16px;
        background: #ff4444;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        z-index: 999999; /* üëà highest priority */
        pointer-events: auto;
        opacity: 0.9;
      }

      #setLocationBtn:disabled {
        background: #888;
        opacity: 0.7;
        cursor: not-allowed;
      }
    </style>
  </head>

  <body>
    <!-- üìç Button now stays visible above AR view -->
    <button id="setLocationBtn">üìç Set Target Location</button>

    <a-scene
      embedded
      arjs="sourceType: webcam; debugUIEnabled: false;"
      vr-mode-ui="enabled: false"
      renderer="logarithmicDepthBuffer: true;"
    >
      <a-marker preset="hiro">
        <a-box id="geo-cube" position="0 0.5 0" color="red" visible="false"></a-box>
      </a-marker>
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      const cube = document.getElementById("geo-cube");
      const btn = document.getElementById("setLocationBtn");

      let targetLat = null;
      let targetLon = null;
      const threshold = 10; // meters

      // üåç Haversine distance formula
      function getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const toRad = (deg) => (deg * Math.PI) / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(lat1)) *
            Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      // üéØ Function to set target location
      btn.addEventListener("click", () => {
        if (!navigator.geolocation) {
          alert("Geolocation not supported on this device.");
          return;
        }

        btn.textContent = "Setting...";
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            targetLat = pos.coords.latitude;
            targetLon = pos.coords.longitude;
            btn.textContent = "‚úÖ Location Set";
            btn.disabled = true;
            console.log(`üéØ Target location set to: ${targetLat}, ${targetLon}`);
            // Start periodic location checks
            checkLocation();
            setInterval(checkLocation, 5000);
          },
          (err) => {
            console.error(err);
            btn.textContent = "‚ùå Failed to Set Location";
          },
          { enableHighAccuracy: true }
        );
      });

      // üöÄ Function to check current distance
      function checkLocation() {
        if (targetLat === null || targetLon === null) return;

        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            const dist = getDistance(latitude, longitude, targetLat, targetLon);
            console.log(`üìç Distance from target: ${Math.round(dist)} m`);

            cube.setAttribute("visible", dist <= threshold);
          },
          (err) => console.error(err),
          { enableHighAccuracy: true }
        );
      }
    </script>
  </body>
</html>
