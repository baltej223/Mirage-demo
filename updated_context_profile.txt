Okay, So let me update your context profile.

- I wanted to make an AR web application.
- Users will be able to see cubes at specific locations, which will be placed by me using firebase geohashing.
- I made a collection mirage-locations, and there I stored all the location [latitude, longitude] with there geohash. 
- The basic code which I used for rendering cubes over the camera input stream in north, south, east, west, location in the AR word is

```JS
import * as THREE from 'three';
import * as LocAR from 'locar';

const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.001, 1000);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
// document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

const locar = new LocAR.LocationBased(scene, camera);

window.addEventListener("resize", e => {
    console.log("resize", e);
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});


const cam = new LocAR.Webcam({
    video: {
        facingMode: "environment"
    }
});

cam.on("webcamstarted", ev => {
    scene.background = ev.texture;
});

cam.on("webcamerror", error => {
    alert(`Webcam error: code ${error.code} message ${error.message}`);
});


const deviceOrientationControls = new LocAR.DeviceOrientationControls(camera);

deviceOrientationControls.on("deviceorientationgranted", ev => {
    ev.target.connect();
});

deviceOrientationControls.on("deviceorientationerror", error => {
    alert(`Device orientation error: code ${error.code} message ${error.message}`);
});

deviceOrientationControls.init();

locar.on("gpserror", error => {
    alert(`GPS error: ${error.code}`);
});

let firstLocation = true;


locar.on("gpsupdate", ev => {
    if(!firstLocation) return ; 
        const boxProps = [{
            latDis: 0.0005,
            lonDis: 0,
            colour: 0xff0000
        }, {
            latDis: -0.0005,
            lonDis: 0,
            colour: 0xffff00
        }, {
            latDis: 0,
            lonDis: -0.0005,
            colour: 0x00ffff
        }, {
            latDis: 0,
            lonDis: 0.0005,
            colour: 0x00ff00
        }];

        const geom = new THREE.BoxGeometry(10,10,10);

        for(const boxProp of boxProps) {
            const mesh = new THREE.Mesh(
                geom, 
                new THREE.MeshBasicMaterial({color: boxProp.colour})
            );
        
            locar.add(
                mesh, 
                ev.position.coords.longitude + boxProp.lonDis, 
                ev.position.coords.latitude + boxProp.latDis
            );
        }
        
        firstLocation = false;
});

locar.startGps();

renderer.setAnimationLoop(animate);

function animate() {
    deviceOrientationControls.update();
    renderer.render(scene, camera);
}


export default renderer;
```
- See in this code is a `locar.on("gpsupdate", ev => { `, a gpsupdate event is fired when the user's device gets a new GPS coords from the navigator application
- Then I wanted to fetch all the location which are in 25 meters radius of user's phones GPS coordinates.
- For that I wrote this hook
```
// services/firestoreGeoQuery.ts
import {
  collection,
  query,
  orderBy,
  startAt,
  endAt,
  getDocs,
  QueryDocumentSnapshot,
//   where, // For additional filters
} from 'firebase/firestore';
import { geohashQueryBounds, distanceBetween } from 'geofire-common'; // Official Firebase lib
import { db } from '../../firebase.ts';

interface GeoPoint {
  lat: number;
  lng: number;
}

interface GeoQueryOptions {
  collectionName: string;
  center: GeoPoint;
  radiusMeters: number;
  additionalFilters?: (q: any) => any; // e.g., add where('category', '==', 'cafe')
}

/**
 * Official Firebase geo query: Geohash bounds + distance filter.
 * For 25m: 1-4 queries, <5 reads typically.
 */
export async function queryWithinRadius({
  collectionName,
  center,
  radiusMeters,
  additionalFilters = (q: any) => q,
}: GeoQueryOptions): Promise<QueryDocumentSnapshot[]> {
  const centerPoint = [center.lat, center.lng] as [number, number];
  const bounds = geohashQueryBounds(centerPoint, radiusMeters); // Lib magic: Returns [[start, end], ...]
  const cityCollection = collection(db, collectionName);
  const promises: Promise<any>[] = [];

  for (const b of bounds) {
    let q = query(
      cityCollection,
      orderBy('geohash'),
      startAt(b[0]),
      endAt(b[1])
    );
    q = additionalFilters(q); // Chain extras
    promises.push(getDocs(q));
  }

  const snapshots = await Promise.all(promises);
  const matches: QueryDocumentSnapshot[] = [];

  for (const snap of snapshots) {
    for (const doc of snap.docs) {
      const { lat, lng } = doc.data();
      if (lat !== undefined && lng !== undefined) {
        const distanceInM = distanceBetween([lat, lng], centerPoint) * 1000; // Lib's Haversine, in km â†’ m
        if (distanceInM <= radiusMeters) {
          matches.push(doc);
        }
      }
    }
  }

  return matches;
}
```
- This hook particularly is not good, cause it fetchs all the docs, and then checks in memory.
- Now my first goal is to render fetch all the location which are in 25 meters radius, and then rendring cubes at those locations.
, for the user to view through AR word through, the phone camera.